import json
import os
from pathlib import Path
import re
from urllib.parse import urlparse, urljoin, quote
from bs4 import BeautifulSoup

# ========== CONFIG ==========
# Ce script est plac√© dans : maker_lens/scripts_recuperation/donnees_harmonisees
BASE_DIR = Path(__file__).resolve().parent

# Dossier o√π sont les JSON bruts :
# ‚Üí c'est exactement donnees_harmonisees et ses sous-dossiers
RAW_DIR = BASE_DIR

# Fichier de sortie pour l'interface :
# maker_lens/interface/js/data.js
# BASE_DIR.parent -> scripts_recuperation
# BASE_DIR.parents[1] -> maker_lens
PROJECT_ROOT = BASE_DIR.parents[1]
OUTPUT_FILE = PROJECT_ROOT / "interface" / "js" / "data.js"
# ============================


def fix_relative_image_urls_in_html(html, source_url):
    """
    Remplace src="/images/..." par src="<origin>/images/..."
    en se basant sur l'URL source (ex: https://wikifab.org/wiki/Truc).
    """
    if not isinstance(html, str) or not source_url:
        return html

    try:
        origin = "{uri.scheme}://{uri.netloc}".format(uri=urlparse(source_url))
    except Exception:
        return html

    # Remplace les chemins relatifs commen√ßant par /images
    def repl(match):
        quote = match.group(1)
        path = match.group(2)
        if path.startswith("/images"):
            return f'src={quote}{origin}{path}{quote}'
        return match.group(0)

    return re.sub(r'src=(["\'])(/[^"\']*)\1', repl, html)


def normalize_tutorial(t):
    """Transforme un JSON harmonis√© en ancien format utilis√© par l'interface."""

    out = {}

    # ---- TITRE ----
    if isinstance(t.get("titre"), str):
        out["titre"] = [t["titre"]]
    else:
        out["titre"] = t.get("titre", [])

    # ---- IMAGE PRINCIPALE ----
    main_img = t.get("main_image_url")
    if main_img:
        img_url = absolutize_url(main_img, t.get("source_link") or t.get("url"))
        out["image"] = [{
            "url": img_url,
            "alt": t.get("titre", ""),
            "description": t.get("main_image_caption", "")
        }]

    # ---- INTRODUCTION ----
    intro_block = build_introduction_block(t)
    if intro_block:
        out["introduction"] = intro_block

    # ---- METADONNEES ----
    if t.get("difficulte"):
        out["difficult√©"] = [clean_difficulty(t["difficulte"])]

    if t.get("duree"):
        out["dur√©e"] = [clean_duration(t["duree"])]

    if t.get("cout"):
        out["co√ªt"] = [t["cout"]]

    if t.get("source_link"):
        out["liens"] = [t["source_link"]]

    # ---- MATERIAUX ----
    mat_block = build_list_block(t.get("materiaux"))
    if mat_block:
        out["mat√©riaux"] = mat_block

    # ---- OUTILS ----
    outils_block = build_list_block(t.get("outils"))
    if outils_block:
        out["outils"] = outils_block

    # ---- ETAPES ----
    etapes = t.get("etapes", [])
    converted_steps = []

    for i, e in enumerate(etapes, start=1):
        html = e.get("html", "") if isinstance(e, dict) else ""

        converted_steps.append({
            "numero": i,
            "titre": f"√âtape {i}",
            "solutions": [
                {
                    "objectif": "",
                    # on conserve le HTML brut dans description pour le rendre c√¥t√© JS
                    "description": html,
                    "images": []
                }
            ]
        })

    if converted_steps:
        out["√©tapes"] = converted_steps

    return out


def preprocess_tutorial_html(tuto):
    """Corrige les URLs relatives dans les champs HTML du tuto."""
    source_url = tuto.get("source_link") or tuto.get("url") or ""

    # 1) intro si tu as un champ HTML brut (facultatif)
    if isinstance(tuto.get("intro"), str):
        fixed = fix_relative_image_urls_in_html(tuto["intro"], source_url)
        fixed = dedupe_images_in_html(fixed)
        tuto["intro"] = fixed

    # 2) √©tapes harmonis√©es (ton cas Wikifab : etapes[i]["html"])
    if isinstance(tuto.get("etapes"), list):
        for etape in tuto["etapes"]:
            if isinstance(etape, dict) and "html" in etape:
                raw = etape["html"]
                fixed = fix_relative_image_urls_in_html(raw, source_url)
                fixed = dedupe_images_in_html(fixed)
                etape["html"] = fixed

    return tuto

def clean_difficulty(raw):
    """
    Nettoie les champs de difficult√© :
    - garde la version FR si le champ est bilingue (Very hard / Tr√®s difficile)
    - corrige des cas comme 'Very hard Tr√®s difficile'
    - mappe quelques valeurs EN ‚Üí FR
    """
    if not raw:
        return ""
    s = str(raw).strip()
    s = re.sub(r"\s+", " ", s)  # espaces multiples ‚Üí espace simple

    # üîπ Cas particulier : "Very hard Tr√®s difficile" (sans slash)
    if re.search(r"very\s+hard.*tr[√®e]s\s+difficile", s, flags=re.IGNORECASE):
        return "Tr√®s difficile"

    # üîπ Cas g√©n√©riques bilingues avec "/"
    if "/" in s:
        parts = [p.strip() for p in s.split("/")]
        fr_keywords = ("facile", "moyen", "moyenne", "difficile", "tr√®s", "tres")

        # On essaie de trouver la partie FR
        for p in parts:
            low = p.lower()
            if any(k in low for k in fr_keywords):
                return p

        # Sinon on garde la derni√®re partie
        return parts[-1]

    # üîπ Mapping simple EN ‚Üí FR pour quelques valeurs
    mapping = {
        "easy": "Facile",
        "medium": "Moyen",
        "hard": "Difficile",
        "very hard": "Tr√®s difficile",
    }
    low = s.lower()
    if low in mapping:
        return mapping[low]

    # fallback : on renvoie tel quel
    return s


def clean_duration(raw):
    """
    Nettoie toutes les dur√©es provenant du scraping.
    Supporte :
    - hour(s), heure(s)
    - day(s), jour(s)
    - minute(s), minute(s)
    - second(s), seconde(s)
    - week(s), semaine(s)
    - month(s), mois
    - doublons anglais+fran√ßais : '2 day(s) jour(s)' -> '2 jours'
    - versions abr√©g√©es : h, min, sec
    """

    if not raw:
        return ""

    s = str(raw).strip().lower()

    # -------------------------------------------------------
    # 1. Remplacement des doublons anglais + fran√ßais
    # ex : "day(s) jour(s)" -> "jours"
    # -------------------------------------------------------
    # mapping -> unit√© fran√ßaise
    dual_patterns = {
        r"hour\(s\)\s*heure\(s\)": "heures",
        r"day\(s\)\s*jour\(s\)": "jours",
        r"minute\(s\)\s*minute\(s\)": "minutes",
        r"second\(s\)\s*seconde\(s\)": "secondes",
        r"week\(s\)\s*semaine\(s\)": "semaines",
        r"month\(s\)\s*mois": "mois"
    }

    for pat, repl in dual_patterns.items():
        s = re.sub(pat, repl, s)

    # -------------------------------------------------------
    # 2. Anglais -> fran√ßais (unit√©s simples)
    # -------------------------------------------------------
    replacements = {
        r"hour\(s\)|hours?|h\b": "heures",
        r"day\(s\)|days?": "jours",
        r"minute\(s\)|minutes?|mn|min\b": "minutes",
        r"second\(s\)|seconds?|sec\b": "secondes",
        r"week\(s\)|weeks?": "semaines",
        r"month\(s\)|months?": "mois"
    }

    for pat, repl in replacements.items():
        s = re.sub(pat, repl, s)

    # -------------------------------------------------------
    # 3. Nettoyage des espaces multiples
    # -------------------------------------------------------
    s = re.sub(r"\s+", " ", s).strip()

    # -------------------------------------------------------
    # 4. Normalisation du singulier
    # -------------------------------------------------------
    s = s.replace("1 heures", "1 heure")
    s = s.replace("1 jours", "1 jour")
    s = s.replace("1 minutes", "1 minute")
    s = s.replace("1 secondes", "1 seconde")
    s = s.replace("1 semaines", "1 semaine")

    return s

def dedupe_images_in_html(html):
    """
    Supprime les <img> dupliqu√©es (m√™me src) dans un bloc HTML.
    Utile pour Wikifab o√π les galeries r√©p√®tent les m√™mes fichiers.
    """
    if not isinstance(html, str) or "<img" not in html.lower():
        return html

    soup = BeautifulSoup(html, "html.parser")
    seen = set()

    for img in soup.find_all("img"):
        src = img.get("src")
        if not src:
            continue
        if src in seen:
            img.decompose()  # la supprimer
        else:
            seen.add(src)

    return str(soup)


def normalize_html_list(html_str):
    """
    Transforme '<ul><li>A</li><li>B</li></ul>' en ['A', 'B'].
    Si pas de <li>, renvoie le texte brut.
    """
    items = []
    soup = BeautifulSoup(html_str, "html.parser")
    for li in soup.find_all("li"):
        text = li.get_text(strip=True)
        if text:
            items.append(text)
    if not items:
        text = soup.get_text(" ", strip=True)
        if text:
            items.append(text)
    return items


def build_list_block(raw_list):
    """
    Convertit une liste de strings ou html en bloc attendu par l'interface :
    [{ "titre": "item1", "sous_items": [] }, ...]
    -> ainsi, on √©vite le 'Liste' et les listes imbriqu√©es moches.
    """
    if not raw_list:
        return []

    sous_items = []
    for item in raw_list:
        if not item:
            continue
        if isinstance(item, str) and "<li" in item:
            sous_items.extend(normalize_html_list(item))
        elif isinstance(item, str):
            sous_items.append(item.strip())
        elif isinstance(item, dict):
            # si jamais tu as d√©j√† un format structur√©
            titre = item.get("titre")
            if titre:
                sous_items.append(titre.strip())

    if not sous_items:
        return []

    # On cr√©e un objet par sous-√©l√©ment, sans "Liste"
    return [
        {"titre": s, "sous_items": []}
        for s in sous_items
    ]



def build_introduction_block(t):
    """
    Logique optimale pour l'introduction :
    - Si intro_items existe -> on utilise uniquement intro_items (rendu plus propre)
    - Sinon si intro existe -> on utilise intro
    - Sinon -> aucune introduction
    """

    # 1) intro_items prioritaire
    items = t.get("intro_items")
    if items and isinstance(items, list) and any(x.strip() for x in items if isinstance(x, str)):
        blocks = []
        for it in items:
            if not it:
                continue
            it_clean = (it or "").strip()
            if it_clean:
                blocks.append({"titre": it_clean, "sous_items": []})
        if blocks:
            return blocks

    # 2) sinon fallback sur intro brut
    intro = (t.get("intro") or "").strip()
    if intro:
        return [{"titre": intro, "sous_items": []}]

    # 3) sinon aucune introduction
    return []



def absolutize_url(url, source_url):
    """
    Rend une URL absolue si possible (pour main_image_url, etc.).
    """
    if not url or not isinstance(url, str):
        return url

    if url.startswith("http://") or url.startswith("https://"):
        return url

    if not source_url:
        return url

    parsed = urlparse(source_url)
    origin = f"{parsed.scheme}://{parsed.netloc}"

    # /images/... -> https://site.org/images/...
    if url.startswith("/"):
        return urljoin(origin, url)

    # Sinon, on tente un join simple
    return urljoin(origin, url)


def load_all_tutorials():
    tutorial_data = {}
    json_files_found = 0

    print(f"üîç Recherche de JSON dans : {RAW_DIR} (existe = {RAW_DIR.exists()})")

    if not RAW_DIR.exists():
        print("‚ùå Le dossier RAW_DIR n'existe pas, v√©rifie le chemin dans le script.")
        return tutorial_data

    # Parcours r√©cursif : dossiers par site, puis sous-dossiers html/json, etc.
    for root, _, files in os.walk(RAW_DIR):
        for fname in files:
            if not fname.lower().endswith(".json"):
                continue

            path = Path(root) / fname
            json_files_found += 1
            print(f"  üìÑ Fichier JSON trouv√© : {path}")

            with path.open("r", encoding="utf-8") as f:
                content = json.load(f)

            # Cas 1 : le fichier contient d√©j√† un mapping {id: tuto, ...}
            if (
                isinstance(content, dict)
                and all(isinstance(v, dict) for v in content.values())
                and not ("titre" in content or "image" in content)
            ):
                for key, tuto in content.items():
                    if key in tutorial_data:
                        print(f"[WARN] Cl√© '{key}' d√©j√† pr√©sente, √©cras√©e par {path}")
                    tuto = preprocess_tutorial_html(tuto)
                    tuto = normalize_tutorial(tuto)
                    tutorial_data[key] = tuto

            else:
                # Cas 2 : un seul tuto par fichier
                tuto = content

                if "id" in tuto:
                    key = tuto["id"]
                elif "titre" in tuto and isinstance(tuto["titre"], list) and tuto["titre"]:
                    key = tuto["titre"][0]
                else:
                    # fallback : nom du fichier sans extension
                    key = path.stem

                # Normalisation de la cl√©
                key_norm = (
                    str(key)
                    .strip()
                    .replace(" ", "_")
                    .replace("/", "_")
                )

                if key_norm in tutorial_data:
                    print(f"[WARN] Cl√© '{key_norm}' d√©j√† pr√©sente, ajout suffixe.")
                    suffix = 2
                    new_key = f"{key_norm}_{suffix}"
                    while new_key in tutorial_data:
                        suffix += 1
                        new_key = f"{key_norm}_{suffix}"
                    key_norm = new_key

                tuto = preprocess_tutorial_html(tuto)
                tuto = normalize_tutorial(tuto)
                tutorial_data[key_norm] = tuto

    print(f"üìä Nombre total de fichiers JSON trouv√©s : {json_files_found}")
    print(f"üìä Nombre total de tutoriels charg√©s : {len(tutorial_data)}")

    return tutorial_data


def main():
    tutorials = load_all_tutorials()

    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)

    with OUTPUT_FILE.open("w", encoding="utf-8") as f:
        f.write("window.tutorialData = ")
        json.dump(tutorials, f, ensure_ascii=False, indent=4)
        f.write(";\n")

    print(f"‚úÖ G√©n√©r√© {OUTPUT_FILE} avec {len(tutorials)} tutoriels.")


if __name__ == "__main__":
    main()
